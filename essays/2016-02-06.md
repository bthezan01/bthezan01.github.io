---
layout: essay
type: essay
title: How Processes Are Used In Operating Systems
# All dates must be YYYY-MM-DD format!
date: 2020-04-26
labels:
  - Computer Science
---

Processes give operating systems purpose.  Many operating systems themselves are just a collection of processes and most of the design for operating systems is based around handling processes.  Without the concept of processes, the world would be without much of the technology we have today.  This paper will look to explore what processes are, what they are made of, how operating systems manage them, and what happens when processes are not managed properly.
	A process can be defined in several ways.  As the 9th edition of Operating Systems: Integrals and Design Principles puts it, a process is:
“a program in execution, an instance of a program running on a computer, the entity that can be assigned to and executed on a processor, [And] a unit of activity characterized by a single sequential thread of execution…”
So in reality, a process is not so much a specific object used in computing, but rather a concept.  In its most simple state, it is just some code or tasks that are being executed.  It can also just be a unit of measuring how much work is being done.  It all depends on the context in which it is being talked about.
Processes are also equipped with a process control block and a PID.  PID stands for process identification number and it’s the number that is assigned to the given process by the OS to help keep track of which process is which.  The process control block is also assigned by the OS.  The GeeksforGeeks web page titled Process Table and Process Control Block says that process control blocks are “Used to track the process’s execution status…” and “contains information about the process, i.e. registers, quantum, priority, etc.”  This tells the OS all the information it needs when handling processes and helps a lot during the process of swapping out other processes.
As stated before, the operating system is designed around the handling of many processes at once.  Even going back to some of the first OS’s, like serial and batch processing systems, the core design concept was based around carrying out various tasks that the user wanted to execute.  Things have grown very complicated since the early years of computing but it’s still all the same in many ways.  One way to simplify how the operating system carries out processes is by looking at the five-state model.  The model shows the possible paths a process can take and it’s called the five-state model because of the 5 possible states that the process can be in.  These states include new, ready, running, blocked, and exit.  When a process is created, it is considered new.  Once it has been admitted into a queue, it is ready.  From here, a dispatcher, which is another process that handles ready processes, will set the process to running.  The process will do what it needs to and exit, or it can become blocked if it needs to wait for an event to happen.  Once the event happens, the process is thrown back into the ready queue and will go back to running shortly.  The OS overlooks this situation along with the processor.
	Processes need to be properly managed or else they can run into many issues that can slow down processing time and even harm the computer.  Some of the main issues include deadlocks and starvation.  Deadlocks, as defined by TutorialsPoint.com, are “when two or more processes need some resource to complete their execution that is held by the other process.”  So if one process relies on another but the other process needs something from the first one then they will both remain blocked and cannot be executed further.  There’s four situations, called Coffman conditions, that will lead to a deadlock if they are true.  These conditions include mutual exclusion, hold and wait, no preemption, and circular wait.  During mutual exclusion, a resource can only be held by one process at a time.  For hold and wait, a process holds resources and requests more from other processes.  In no preemption, a process can not get a resource by force and must wait for it to be released by the process that is using it.  Lastly, circular wait happens when a process waits on a resource used by another process, and that process is waiting on the resource used by the first process.  So if most of these conditions occur, then a deadlock is bound to happen.  As for starvation, it’s a bit different.  Starvation is when a process needs a resource, but other processes keep using that resource.  Therefore, the first process never gets access to the resource and becomes starved.  It’s different from a deadlock because in this instance, only one process is stuck.
Processes are incredibly important and the heart of any computer system.  Without them, all that’s left is an empty computer with nothing to do.  Every OS is designed to be as efficient as possible with processes in order to give the best and fastest user experience.  If an OS can not manage to effectively utilize processing time and prevent deadlocks, then it will surely fail out in the computer market.
